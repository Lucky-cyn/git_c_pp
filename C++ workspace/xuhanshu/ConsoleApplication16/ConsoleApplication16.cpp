//// ConsoleApplication16.cpp : 定义控制台应用程序的入口点。
////
//
#include "stdafx.h"
#include <iostream>
#include <string>
using namespace std;

class Student
{
public:
	Student(int, string, float);
	virtual void display();
protected:
	int num;
	string name;
	float score;
};

Student::Student(int n, string nam, float s)
{
	num = n;
	name = nam;
	score = s;
}

void Student::display()
{
	cout << "num:" << num << "\nname:" << name << "\nscore:" << score << "\n\n";
}

class Graduate :public Student
{
public:
	Graduate(int, string,float, float);
	virtual void display();
private:
	float pay;
};

void Graduate::display()
{
	cout << "num:" << num << "\nname:" << name << "\nscore:" << score << "\npay=" << pay << endl;
}

Graduate::Graduate(int n, string nam, float s, float p) :Student(n, nam, s), pay(p) {}

int main()
{
	Student stud1(1001,"LI",87.5);
	Graduate grad1(2001, "wang", 98.5, 88.1);
	Student *pt = &stud1;
	pt->display();
	pt = &grad1;
	pt->display();

	return 0;
}
//说明：本来基类指针是用来指向基类对象的，如果用它指向派生类对象，则进行指针类型转换，
//将派生类对象的指针先转换为基类的指针，所以基类指针指向的是派生类对象中的基类部分。
//在程序修改前，是无法通过基类指针去调用派生类对象中的成员函数的。
//虚函数突破了这一限制，在派生类的基类部分中，派生类的虚函数取代了基类原来的虚函数，
//因此在使基类指针指向派生类对象后，调用虚函数时就调用了派生类的虚函数。 要注意的是，
//只有用virtual声明了虚函数后才具有以上作用。如果不声明为虚函数，企图通过基类指针调用派生类的非虚函数是不行的。


//
//虚函数的以上功能是很有实用意义的。在面向对象的程序设计中，经常会用到类的继承，
//目的是保留基类的特性，以减少新类开发的时间。但是，从基类继承来的某些成员函数不完全适应派生类的需要，
//例如在例12.2中，基类的display函数只输出基类的数据，而派生类的display函数需要输出派生类的数据。
//过去我们曾经使派生类的输出函数与基类的输出函数不同名（如display和display1），但如果派生的层次多，就要起许多不同的函数名，
//很不方便。如果采用同名函数，又会发生同名覆盖。



//利用虚函数就很好地解决了这个问题。可以看到：
//当把基类的某个成员函数声明为虚函数后，允许在其派生类中对该函数重新定义，赋予它新的功能，
//并且可以通过指向基类的指针指向同一类族中不同类的对象，从而调用其中的同名函数。
//由虚函数实现的动态多态性就是：同一类族中不同类的对象，对同一函数调用作出不同的响应。



//虚函数的使用方法是：
//
//1、在基类用virtual声明成员函数为虚函数。
//这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用。在类外定义虚函数时，不必再加virtual。
//
//2、在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体。
//C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此在派生类重新声明该虚函数时，可以加virtual，
//也可以不加，但习惯上一般在每一层声明该函数时都加virtual，使程序更加清晰。
//如果在派生类中没有对基类的虚函数重新定义，则派生类简单地继承其直接基类的虚函数。
//
//3、定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。
//
//4、通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数。
//通过虚函数与指向基类对象的指针变量的配合使用，就能方便地调用同一类族中不同类的同名函数，只要先用基类指针指向即可。
//如果指针不断地指向同一类族中不同类的对象，就能不断地调用这些对象中的同名函数。
//这就如同前面说的，不断地告诉出租车司机要去的目的地，然后司机把你送到你要去的地方。
//
//需要说明：有时在基类中定义的非虚函数会在派生类中被重新定义(如例12.1中的area函数)，
//如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；
//如果用派生类指针调用该成员函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为(使用的是不同类型的指针)，没有用到虚函数的功能。
//
//以前介绍的函数重载处理的是同一层次上的同名函数问题，
//而虚函数处理的是不同派生层次上的同名函数问题，前者是横向重载，后者可以理解为纵向重载。
//但与重载不同的是 : 同一类族的虚函数的首部是相同的，而函数重载时函数的首部是不同的(参数个数或类型不同)。